#!/bin/bash

GREEN="\u001b[32m"
MAGENTA="\u001b[35m"
CYAN="\u001b[36m"
YELLOW="\033[33m"
RESET="\033[0m"
RED="\033[0;31m"

alias glo='git log --oneline'
alias ..="cd .." # TODO try to get the same behavior as zsh


function upper() {
   echo $1 | tr '[:lower:]' '[:upper:]'
}

function log() {
   declare -A levels=( ["info"]="$CYAN" ["error"]="$RED" ["action"]="$MAGENTA" ["ask"]="$YELLOW" )
   log_level=$1

   if [[ ${options[quiet]} == true ]] && [[ $log_level != "error" ]] ; then
      return 125 # operation canceled code
   fi

   display_level=$(upper $log_level)
   printf "${levels[$log_level]}[$display_level]$RESET ${@:2}\n\n"
}

function fpush() {
   branch=`git branch --show-current`
   display_branch=$(upper $branch)
   log info "pushing and setting upstream to $GREEN${display_branch}$RESET"

   git push $1 --set-upstream origin $branch $2
}

function commit() {
   git add .

   printf "commiting files\n\n"

   printf "$GREEN"
   git diff --name-only --cached
   printf "$RESET\n"

   for opt in $@; do
      if [[ $opt == -* ]]; then
         if [[ $opt == --* ]]; then
            options[${opt:2}]=true
         else
            options[${opt:1}]=true
         fi
         shift
      fi
   done

   inputed_message="$1"
   shift
   rest_args="$@"

   if test -z "$inputed_message"
   then
      commitmsg=`git branch --show-current | awk '{gsub("/",": "); print}' | awk '{gsub("-"," "); print}'`
   else
      commitmsg="$inputed_message"
   fi

   printf "with message$GREEN $commitmsg$RESET\n\n"

   printf "please confirm [Y/n]: "

   read -p "" -n 1 -r
   if [[ $REPLY =~ ^[Yy]$ ]]
   then
      echo
      git commit -m "${commitmsg}" $rest_args
   else
      echo
      printf "${RED}exiting...$RESET\n"
      git reset
   fi
}

function checkout() {
   current_branch=$(git branch --show-current)

   if test -z "$1"; then
      branch_to_checkout=$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@')
   else
      branch_to_checkout="$1"
   fi

   if [ $current_branch != $branch_to_checkout ]; then
      git checkout $branch_to_checkout
   fi

   git pull --rebase --quiet

   local_branchs=$(git for-each-ref --format='%(refname:short)' refs/heads/ | sed s/$branch_to_checkout// )

   if test -n "$local_branchs"; then
      echo $local_branchs | xargs git branch -D
   fi
}

function git_branch() {
  git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1)/'
}

DEFAULT_PS1="\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]"

export PS1="$DEFAULT_PS1 \$(git_branch) ‚ùØ "
